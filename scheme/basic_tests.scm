(display "          === Testing Literals ===")
(newline)
(test-equal 42 42 "Integer literal")
(test-equal 3.14 3.14 "Float literal")
(test-equal "hello" "hello" "String literal")
(test-equal #t #t "Boolean true literal")
(test-equal #f #f "Boolean false literal")
(test-equal #\a #\a "Character literal")
(test-nil '() "Nil literal")
(test-symbol 'foo "Symbol literal")

(display "          === Testing Arithmetic ===")
(newline)
(test-equal 3 (+ 1 2) "Simple addition")
(test-equal 12 (* 3 4) "Simple multiplication")
(test-equal -5 (- 5 4 3 2 1) "Subtraction with multiple args")
(test-equal 0.3 (/ 6 5 4) "Division with multiple args")
(test-equal 15 (+ 1 2 3 4 5) "Addition with multiple args")
(test-equal 120 (* 2 3 4 5) "Multiplication with multiple args")
(test-equal 83 (- 100 10 5 2) "Subtraction with multiple args")
(test-true (inexact? 3.14) "inexact? with float")
(test-false (inexact? 42) "inexact? with integer")
(test-true (inexact? 3.14) "inexact? with float")
(test-false (inexact? 42) "inexact? with integer")
(test-true (exact? 42) "exact? with integer")
(test-false (exact? 3.14) "exact? with float")
(test-true (exact? 42) "exact? with integer")
(test-false (exact? 3.14) "exact? with float")
(test-equal 1 (modulo 7 3) "modulo basic")
(test-equal 2 (modulo 8 3) "modulo with remainder")
(test-equal 0 (modulo 9 3) "modulo exact division")
;; Comparison tests
(test-true (= 5 5) "equality same numbers")
(test-true (= 5 5.0) "equality int and float")
(test-false (= 5 6) "equality different numbers")
(test-true (= 1 1 1) "equality multiple same")
(test-false (= 1 1 2) "equality multiple different")

(test-true (< 1 2) "less than basic")
(test-true (< 1 2 3) "less than multiple")
(test-false (< 1 2 2) "less than not strict")
(test-false (< 3 2 1) "less than decreasing")

(test-true (> 3 2) "greater than basic")
(test-true (> 5 4 3) "greater than multiple")
(test-false (> 5 4 4) "greater than not strict")
(test-false (> 1 2 3) "greater than increasing")
;; New R5RS numeric functions
(test-equal 3 (quotient 10 3) "quotient basic")
(test-equal -3 (quotient -10 3) "quotient negative dividend")
(test-equal 1 (remainder 10 3) "remainder basic")
(test-equal -1 (remainder -10 3) "remainder negative dividend")

(test-equal 5 (numerator 5) "numerator integer")
(test-equal 1 (denominator 5) "denominator integer")
(test-equal 5 (numerator 5.0) "numerator exact float")
(test-equal 1 (denominator 5.0) "denominator exact float")

(test-equal 3 (floor 3.7) "floor positive")
(test-equal -4 (floor -3.2) "floor negative")
(test-equal 5 (floor 5) "floor integer")

(test-equal 4 (ceiling 3.2) "ceiling positive")
(test-equal -3 (ceiling -3.7) "ceiling negative")
(test-equal 5 (ceiling 5) "ceiling integer")

(test-equal 3 (truncate 3.7) "truncate positive")
(test-equal -3 (truncate -3.7) "truncate negative")
(test-equal 5 (truncate 5) "truncate integer")

(test-equal 4 (round 3.7) "round up")
(test-equal 3 (round 3.2) "round down")
(test-equal 4 (round 3.5) "round half")
(test-equal 5 (round 5) "round integer")

(test-equal 3.0 (sqrt 9) "sqrt perfect square")
(test-equal 2.0 (sqrt 4.0) "sqrt float")

(test-equal 8 (expt 2 3) "expt integer base and exp")
(test-equal 8 (expt 2.0 3) "expt float base")
(test-equal 0.25 (expt 2 -2) "expt negative exp")
(test-equal 1 (expt 5 0) "expt zero exp")

(display "          === Testing Type Predicates ===")
(newline)
(test-true (integer? 22) "integer? with integer")
(test-false (integer? nil) "integer with nil")
(test-true (float? 3.14) "float? with float")
(test-false (float? 3) "float? with integer")
(test-true (number? 42) "number? with integer")
(test-true (number? 3.14) "number? with float")
(test-false (number? "not a number") "number? with string")
(test-true (symbol? 'foo) "symbol? with symbol")
(test-false (symbol? 42) "symbol? with number")
(test-true (string? "hello") "string? with string")
(test-false (string? 42) "string? with number")
(test-true (boolean? #t) "boolean? with true")
(test-true (boolean? #f) "boolean? with false")
(test-false (boolean? 42) "boolean? with number")
(test-true (char? #\a) "char? with character")
(test-false (char? 42) "char? with number")
(test-true (pair? '(1 2)) "pair? with pair")
(test-false (pair? 42) "pair? with number")
(test-true (eq? '() '()) "nil? with nil")
(test-false (eq? '(1 2) '()) "nil? with list")
(test-true (vector? #(1 2 3)) "vector? with vector")
(test-false (vector? 42) "vector? with number")

(display "          === Testing Type-of ===")
(newline)
(test-equal 'integer (type-of 42) "type-of with integer")
(test-equal 'float (type-of 3.14) "type-of with float")
(test-equal 'string (type-of "hello") "type-of with string")
(test-equal 'boolean (type-of #t) "type-of with boolean")
(test-equal 'boolean (type-of #f) "type-of with boolean")
(test-equal 'char (type-of #\a) "type-of with character")
(test-equal 'null (type-of ()) "type-of with nil")
(test-equal 'symbol (type-of 'symbol) "type-of with symbol")
(test-equal 'pair (type-of '(1 2 3)) "type-of with pair")

(display "          === Testing List Literals ===")
(newline)
(test-equal '(1 2 3) '(1 2 3) "List literal")
(test-equal '(a b c) '(a b c) "Symbol list literal")
(test-equal '(1 (+ 2 3) 4) '(1 (+ 2 3) 4) "List with quoted expression")
(test-equal '(1 2 3 4 5) '(1 2 3 4 5) "Longer list literal")

(display "          === Testing Begin ===")
(newline)
(test-equal 3 (begin 1 2 3) "Simple begin")
(test-equal 12 (begin (+ 1 2) (* 3 4)) "Begin with expressions")
(test-equal 5 (begin 1 2 3 4 5) "Begin with multiple expressions")

(display "          === Testing Variables ===")
(newline)
(define x 22)
(define y 'z)
(define a 10)
(define b 20)
(define w (+ 5 5))
(define v 'hello)
(test-equal 22 x "Variable lookup after define")
(test-equal 'z y "Symbol variable lookup")
(test-equal 50 (+ a (* b 2)) "Complex variable expression")
(test-equal 10 w "Define with expression")
(test-equal 'hello v "Define with symbol")

(display "          === Testing Set! ===")
(newline)
(define x 10)
(set! x 42)
(set! x 'foo)
(define z 100)
(set! z 200)
(set! z (+ z 50))
(test-equal 42 42 "set! with number")
(test-equal 'foo 'foo "set! with symbol")
(test-equal 200 200 "set! with number")
(test-equal 250 250 "set! with expression")

(display "          === Testing If ===")
(newline)
(test-equal 1 (if #t 1 2) "if with true condition")
(test-equal 2 (if #f 1 2) "if with false condition")
(test-equal 5 (if #t 5) "if without alternate")
(test-equal 3 (if #t (+ 1 2) (- 1 2)) "if with expressions")
(test-equal -1 (if #f (+ 1 2) (- 1 2)) "if with expressions, false")
(test-equal 11 (if (> 10 5) (+ 10 1) (- 10 1)) "if with comparison")
(test-equal 22 (cond ((= 3 3) 22) (else "failed")) "cond with boolean expr")
(test-equal 22 (cond (else 22)) "minimal cond with else")
(test-equal 66 (cond (#f 22 33) (#f 44 55) (else (define zz "ok") 66)) "cond with implicit begin")
(test-equal zz "ok" "cond else with implicit begin")

(display "          === Testing And/Or ===")
(newline)
(test-true (and) "Empty and")
(test-equal 2 (and #t 1 2) "'and' with all truthy (numbers)")
(test-false (and #t #f 1) "'and' with false")
(test-false (or) "Empty 'or'")
(test-false (or #f #f) "'or' with all false")
(test-equal 1 (or #f 1 2) "'or' with true")
(test-equal 3 (or #f #f 3) "'or' with last true")
(test-true (and #t #t #t) "'and' with all #t")
(test-false (and #t #f #t) "'and' with middle false")
(test-false (or #f #f #f) "'or' with all false")
(test-true (or #f #t #f) "'or' with middle true")

(display "          === Testing Quote ===")
(newline)
(test-equal 42 '42 "Quote number")
(test-true '#t "Quote boolean")
(test-equal "hello" '"hello" "Quote string")
(test-equal #\a '#\a "Quote character")

(display "          === Testing Lambda ===")
(newline)
(define add1 (lambda (x) (+ x 1)))
(define make-adder (lambda (n) (lambda (x) (+ x n))))
(define add5 (make-adder 5))
(test-equal 6 (add1 5) "Simple lambda application")
(test-equal 7 ((lambda (x y) (+ x y)) 3 4) "Immediate lambda application")
(test-equal 8 (add5 3) "Closure application")
(define fact (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
(test-equal 720 (fact 6) "Factorial test")
(define fac-acc (lambda (n)
    (define f (lambda (n acc)
        (if (= n 0)
            acc
            (f (- n 1) (* acc n)))))
    (f n 1)))
(test-equal 720 (fac-acc 6) "Factorial test with nested define and accumulator")

(display "          === Testing Define Forms ====")
(newline)
(define (add a b) (+ a b))
(test-equal 5 (add 2 3) "define standard function")

(define (sum . nums) (apply + nums))
(test-equal 10 (sum 1 2 3 4) "define variadic function")
(test-equal 0 (sum) "define variadic function with no args")

(define (mixed a b . rest) (list a b rest))
(test-equal '(1 2 (3 4)) (mixed 1 2 3 4) "define mixed-arity function")
(test-equal '(1 2 ()) (mixed 1 2) "define mixed-arity function with no rest args")

(display "          === Testing Local Define === ")
(newline)
(test-equal 22 (let () (define foobar 22) foobar) "Local define in let")

(define (test-local-define)
  (define x 10)
  (define (y) 20)
  (+ x (y)))

(test-equal 30 (test-local-define) "Local define in function")

(test-equal 3 (let* () (define x 3) x) "Local define in let*")
(test-equal 30 (letrec ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1))))) 
                         (odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))) 
                  (define x 10) 
                  (define y 20) 
                  (+ x y)) "Local define in letrec")


(display "          === Testing List Accessors ===")
(newline)
(test-equal 1 (car '(1 2 3)) "car of list")
(test-equal '(2 3) (cdr '(1 2 3)) "cdr of list")
(test-equal 2 (cadr '(1 2 3)) "cadr of list")
(test-equal 3 (caddr '(1 2 3 4)) "caddr of list")
(test-equal 1 (caar '((1 2) (3 4))) "caar of nested list")
(test-equal '(2) (cdar '((1 2) (3 4))) "cdar of nested list")
(test-equal '(3 4) (cadr '((1 2) (3 4))) "cadr of nested list")
(test-equal 3 (list-ref '(0 1 2 3) 3) "list-ref last item")
(test-equal 0 (length '()) "zero-length list")
(test-equal 3 (length '(3 2 1)) "single level list")
(test-equal 1 (length '((1 2 3))) "nested list")

(display "          === Testing List Construction ===")
(newline)
(test-equal '(1 . 2) (cons 1 2) "cons with atom")
(test-equal '(1 2 3) (cons 1 '(2 3)) "cons with list")
(test-equal '() (list) "empty list")
(test-equal '(42) (list 42) "single element list")
(test-equal '(1 2 3) (list 1 2 3) "multiple element list")
(test-equal '(1 2 3 4) (append '(1 2) '(3 4)) "append two lists")
(test-equal '(1 2) (append '(1 2) '()) "append with empty list")
(test-equal 'a (append '() 'a) "append with atomic last element")
(test-equal '(a b c . d) (append '(a b) '(c . d)) "append with dotted pair as last element")
(define foo '(a b))
(test-equal '(1 b) (begin (set-car! foo 1) foo)  "set-car! on list")
(test-equal '(1 . 2) (begin (set-cdr! foo 2) foo)  "set-cdr! on list")
(test-equal '(1 2 3) (begin (set-cdr! foo (list 2 3)) foo)  "set-cdr! on list")
(define bar '(x y))
(define ref bar)
(set-car! bar 'z)
(test-true (eq? ref bar) "mutated pair is the same object")
(test-equal '(5 4 3 2 1) (reverse '(1 2 3 4 5)) "reverse list")
(test-equal '(3 4 5) (list-tail '(3 4 5) 0) "degenerate list-tail")
(test-equal '(4 5) (list-tail '(2 3 4 5) 2) "list tail")

(display "          === Testing Comparisons ===")
(newline)
(test-true (= 5 5) "Equal numbers")
(test-true (= 5 5.0) "Equal int and float")
(test-false (= 5 6) "Unequal numbers")
(test-true (< 1 2 3) "Strictly increasing")
(test-false (< 1 2 2) "Not strictly increasing")
(test-true (> 3 2 1) "Strictly decreasing")
(test-false (> 3 2 2) "Not strictly decreasing")
(test-equal 4 (min 5 4 6) "min with integers")
(test-equal 3.14 (min 5 6 7.8 3.14) "min with int and float")

(display "          === Testing Vectors ===")
(newline)
(test-equal 4 (vector-length (vector 1 2 3 4)) "vector-length")
(test-equal '#(9 8 7) (vector 9 8 7) "vector constructor with numbers")
(test-equal '#(a b c) (vector 'a 'b 'c) "vector constructor with symbols")
(test-equal 10 (vector-length (make-vector 10)) "make-vector length check")
(test-equal '#() (make-vector 0 99) "zero length make-vector")
(test-equal '#(9 9 9) (make-vector 3 9) "make-vector with fill")
(test-equal '#(2 2 2) (vector-fill! (vector 4 5 6) 2) "vector-fill")
(test-equal '(1 2 3) (vector->list (vector 1 2 3)) "vector->list")
(test-equal '(1) (vector->list (vector 1)) "vector->list")

(display "          === Testing Strings ===")
(newline)
(test-equal "22" (>string 22) "Integer to string")
(test-equal "22.5" (>string 22.5) "Float to string")
(test-equal "hello" (>string "hello") "String to string")
(test-equal "(1 2 3)" (>string '(1 2 3)) "List to string")
(test-equal 5 (string-length "hello") "string-length")
(test-equal 0 (string-length "") "string-length of empty string")
(test-equal "now is the time" (string-downcase "Now Is The Time") "string-downcase")
(test-equal "NOW IS THE TIME" (string-upcase "Now Is The Time") "string-upcase")
(test-equal "Now is the time" (string-append "Now " "is " "the time") "string-append")
(test-equal "A copied string" (string-copy "A copied string") "string-copy")
(test-equal #\3 (string-ref "012345" 3) "string-ref")
(test-equal #\A (string-ref "A copied string" 0) "string-ref")
(test-equal "A cop" (substring "A copied string" 0 4) "substring")
(test-true (string=? "hello" "hello") "string=?")
(test-false (string=? "hello" "world") "string=?")
(test-true (string<? "apple" "banana") "string<?")
(test-false (string<? "apple" "apple") "string<?")
(test-true (string<? "apple" "chinook") "string<?")
(test-false (string>? "apple" "banana") "string>?")
(test-false (string>? "apple" "apple") "string>?")
(test-equal "133" (number->string 133) "number->string with int")
(test-equal "-4.55" (number->string -4.55) "number->string with float")
(test-equal "12345678901234567890" (number->string 12345678901234567890) "number->string with bigint")
(test-equal -9 (string->number "-9") "string->number with int")
(test-equal 4.55 (string->number "4.55") "string->number with float")
(test-equal 1234567890123456789055 (string->number "1234567890123456789055") "string->number with bigint")
(test-equal 123 (string->number "    123 ") "string->number with whitespace")

(display "          === Testing Characters ===")
(newline)
(test-true (char=? #\a #\a) "char=? same chars")
(test-false (char=? #\a #\b) "char=? different chars")
(test-true (char<? #\a #\b) "char<?")
(test-false (char<? #\b #\a) "char<?")
(test-false (char<? #\a #\a) "char<? same chars")
(test-true (char>? #\b #\a) "char>?")
(test-false (char>? #\a #\b) "char>?")
(test-false (char>? #\a #\a) "char>? same chars")
(test-equal 97 (char->integer #\a) "char->integer")
(test-equal #\a (integer->char 97) "integer->char")

(test-true (char-alphabetic? #\a) "char-alphabetic? lower")
(test-true (char-alphabetic? #\Z) "char-alphabetic? upper")
(test-false (char-alphabetic? #\5) "char-alphabetic? numeric")
(test-false (char-alphabetic? #\space) "char-alphabetic? whitespace")

(test-true (char-numeric? #\1) "char-numeric? numeric")
(test-false (char-numeric? #\a) "char-numeric? alphabetic")

(test-true (char-whitespace? #\space) "char-whitespace? space")
(test-true (char-whitespace? #\newline) "char-whitespace? newline")
(test-true (char-whitespace? #\tab) "char-whitespace? tab")
(test-false (char-whitespace? #\a) "char-whitespace? alphabetic")

(test-true (char-upper-case? #\A) "char-upper-case? upper")
(test-false (char-upper-case? #\a) "char-upper-case? lower")

(test-true (char-lower-case? #\a) "char-lower-case? lower")
(test-false (char-lower-case? #\A) "char-lower-case? upper")
(test-equal "aaaaa" (make-string 5 #\a) "make-string with char")
(test-equal "     " (make-string 5) "make-string without char")
(test-equal '(#\a #\b #\c) (string->list "abc") "string->list")
(test-equal '() (string->list "") "string->list with empty string")
(define s (string-copy "abc"))
(string-set! s 1 #\z)
(test-equal "azc" s "string-set!")

(display "          === Testing Character I/O ===")
(newline)
(define char-port (open-input-file "tests/char_test.txt"))

(test-true (input-port? char-port) "Port is an input port")
(test-true (char-ready? char-port) "char-ready? on open port")
(test-equal #\a (peek-char char-port) "peek-char on fresh port")
(test-equal #\a (peek-char char-port) "peek-char again does not advance")
(test-equal #\a (read-char char-port) "read-char reads first char")
(test-equal #\b (read-char char-port) "read-char reads second char")
(test-true (char-ready? char-port) "char-ready? after reading")
(test-equal #\c (peek-char char-port) "peek-char on last char")
(test-equal #\c (read-char char-port) "read-char reads last char")

;; Test End of File
(test-true (eof-object? (peek-char char-port)) "peek-char at EOF")
(test-true (eof-object? (read-char char-port)) "read-char at EOF")

(close-input-port char-port)

(display "          === Testing File I/O ===")
(newline)

;; Test call-with-input-file
(test-equal #\a (call-with-input-file "tests/char_test.txt"
                  (lambda (port) (read-char port)))
            "call-with-input-file reads first character")

;; Test call-with-input-file with multiple operations
(test-equal '(#\a #\b) (call-with-input-file "tests/char_test.txt"
                         (lambda (port)
                           (list (read-char port) (read-char port))))
            "call-with-input-file reads multiple characters")

;; Test call-with-input-file with read function
(test-equal 'abc (call-with-input-file "tests/char_test.txt"
                   (lambda (port) (read port)))
            "call-with-input-file with read function")

;; Test that call-with-input-file properly closes file (basic functionality test)
(define result-from-file #f)
(set! result-from-file
      (call-with-input-file "tests/char_test.txt"
        (lambda (port)
          (list (read-char port) (read-char port) (read-char port)))))
(test-equal '(#\a #\b #\c) result-from-file "call-with-input-file returns result correctly")

;; Test call-with-output-file basic functionality
;; Note: Due to current file I/O limitations, we test the function structure rather than file content
(define output-result #f)
(set! output-result
      (call-with-output-file "tests/test-output-temp.txt"
        (lambda (port)
          (display "test" port)
          "function-completed")))
(test-equal "function-completed" output-result "call-with-output-file returns result correctly")

;; Test that files are properly closed (port should be invalid after call)
(define test-port-closed #f)
(call-with-input-file "tests/char_test.txt"
  (lambda (port) (set! test-port-closed port)))
;; Note: We can't easily test that the port is closed without causing an error

(display "          === Testing Equality ===")
(newline)
(test-true (eq? 'foo 'foo) "Equal symbols")
(test-false (eq? 'foo 'bar) "Unequal symbols")
(test-true (eq? 42 42) "Equal numbers")
(test-false (eq? 42 43) "Unequal numbers")
(test-true (equal? '(1 2) '(1 2)) "Equal lists")
(test-false (equal? '(1 2) '(1 3)) "Unequal lists")

(display "          === Testing eval and apply ===")
(newline)
(test-true (eq? (eval '(+ 1 2)) 3) "eval")
(test-true (eq? (apply + '(1 2)) 3) "apply")
(test-true (eq? (eval '(+ 1 2)) (apply + '(1 2))) "eval and apply")
(define square (lambda (x) (* x x)))
(test-equal 144 (apply square '(12)) "Apply with closure")
(test-equal '(a . b) (apply cons '(a b)) "Apply giving dotted pair")
(test-equal '((1 2) 3 4)(apply apply (list list '(1 2) '(3 4))) "Nested apply")
(test-equal #(1 2 3) (apply vector '(1 2 3)) "Apply creating vector")
(define tail (lambda (x) (apply values (list x))))
(test-equal 5 (tail 5) "Apply with (values ...)")
(define (g . lst) lst)
(test-equal '((1 2 3)) (apply g '((1 2 3))) "apply with doubly nested list")
(test-equal '(1 (2 3)) (apply g 1 '((2 3))) "apply with doubly nested list")

(display "          === Testing Recursion ===")
(define fact
    (lambda (n)
        (if (zero? n) 1 (* n (fact (- n 1))))))
(newline)
(test-equal 1 (fact 0) "Factorial(0)")
(test-equal 720 (fact 6) "Factorial(6)")
(define fib
    (lambda (n)
        (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))))
(test-equal 13 (fib 7) "Fibonacci(7)")
(test-equal 6765 (fib 20) "Fibonacci(20)")
(test-equal '(720) (list (fac-acc 6)) "Tail recursion inside a form")
(define test-tail (lambda (n) (if (= n 0) #t (test-tail (- n 1)))))
(test-true (test-tail 7000) "(test-tail 7000) - fails without tail recursion")

(display "          === Testing Advanced Math === ")
(newline)
(test-equal 1.0 (exp 0) "exp of 0 is 1.0")
(test-true (> (exp 1) 2.718) "exp of 1 is > 2.718")
(test-true (< (exp 1) 2.719) "exp of 1 is < 2.719")
(test-equal 0.0 (log 1) "log of 1 is 0.0")
(test-equal 1.0 (log (exp 1)) "log of exp of 1 is 1.0")
(test-equal 0.0 (sin 0) "sin of 0 is 0.0")
(test-equal 1.0 (cos 0) "cos of 0 is 1.0")
(test-equal 0.0 (tan 0) "tan of 0 is 0.0")
(test-equal 0.0 (asin 0) "asin of 0 is 0.0")
(test-true (> (acos 0) 1.57) "acos of 0 is > 1.57")
(test-true (< (acos 0) 1.58) "acos of 0 is < 1.58")
(test-equal 0.0 (atan 0) "atan of 0 is 0.0")

(display "          === Testing Char Case === ")
(newline)
(test-equal #\A (char-upcase #\a) "char-upcase on lowercase")
(test-equal #\A (char-upcase #\A) "char-upcase on uppercase")
(test-equal #\a (char-downcase #\A) "char-downcase on uppercase")
(test-equal #\a (char-downcase #\a) "char-downcase on lowercase")
(test-equal #\1 (char-upcase #\1) "char-upcase on non-alphabetic")
(test-equal #\1 (char-downcase #\1) "char-downcase on non-alphabetic")

(display "          === Testing More String Functions === ")
(newline)
(test-equal "abc" (string #\a #\b #\c) "string constructor")
(test-true (string<=? "abc" "abd") "string<=? less")
(test-true (string<=? "abc" "abc") "string<=? equal")
(test-false (string<=? "abd" "abc") "string<=? greater")
(test-equal "abc" (list->string '(#\a #\b #\c)) "list->string")
(define s (string-copy "abc"))
(string-fill! s #\z)
(test-equal "zzz" s "string-fill!")


